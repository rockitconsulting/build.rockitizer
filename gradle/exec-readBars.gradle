/*
*	Copyright 2015 rockit.consulting GbR  (www.rockit.consulting)
*
*/


ext {
}





/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
/*        					Read Bars parrallel and sequential and detect delta                                                 */
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/





task cleanPropsInBuild  {
	doLast {
	   description "Cleans properties workspace"
	   new File("${buildDir}${fileSeparator}bar.properties${fileSeparator}in").deleteDir()
	   barPropertiesIn.mkdirs()
	   barPropertiesOut.mkdirs()
	}
}

task readBars(dependsOn:["doReadBars"]) 



//No parallel execution by file writing, due to performance dropdowns
/*
task readBars(dependsOn:["doReadBars${parallel}"]) << {
	bars.each { bar ->
		if( "${ant.project.properties}.${bar.name}" ) {
			logger.lifecycle "writing ${bar.name} to ${barPropertiesIn}${fileSeparator}${bar.name}.properties"
			new File("${barPropertiesIn}${fileSeparator}${bar.name}.properties").withWriter('UTF-8') { fileWriter ->
				"${ant.project.properties}.${bar.name}".writeTo(fileWriter)
			}
		}		

	}
} 
*/	



task doReadBars(dependsOn:[cleanPropsInBuild, findBarFiles,prepareBroker])

bars.each { bar ->
	 task "readBar-${bar}" {
	 	doLast {
		        def result = javaexec {
	      	           logger.lifecycle "[build:rockITizer] writing ${bar} to ${barPropertiesIn}${fileSeparator}${bar}.properties"
				       classpath sourceSets.main.runtimeClasspath.asPath
				       main = "com.ibm.broker.config.util.ReadBar"
				       args = ["-runtime", "-b", "${barByName(bar)}","-r"]
		               standardOutput = new FileOutputStream("${barPropertiesIn}${fileSeparator}${bar}.properties")
				}
		}					        
	 }
	 doReadBars.dependsOn "readBar-${bar}"	 
}





task doReadBarsParallel(dependsOn:[findBarFiles,prepareBroker]) {
	doLast {
	    ant.parallel(threadsPerProcessor: 1) {
			bars.each { bar ->
		    		ant.java(outputproperty: "${bar}", fork:'true',failonerror:'yes',classname:"com.ibm.broker.config.util.ReadBar",classpath:sourceSets.main.runtimeClasspath.asPath) {
						arg(line:"-runtime -b ${barByName(bar)} -r")
					}
	        }
	    }
	}    
    
}



/* strip empty properties, keep only key=values */
task stripBars(dependsOn:[readBars]) {
	doLast {
	   barPropertiesIn.listFiles().each { file ->
	   	  def strip =  new File(barPropertiesIn.path+fileSeparator+file.name+'.strip') 
	   	  
	   	   //TODO needs better and performanter solution. One property for one app. No combining. Using all properties and not only thel ines containing equals.
	   	  file.eachLine { line ->
	   	     if(line.contains('#')) { strip << line + lineSeparator }
	   	  }
	   	  file.delete()
	   	  strip.renameTo(new File(file.path)) 
	   	  strip.delete()
	   }
	}	
}



/* combine empty properties, keep only key=values */
task combineBars(dependsOn:[stripBars]) {
	doLast {
	   def result = new File(barPropertiesIn.path+fileSeparator+'combined.bar.properties')
	   
	   barPropertiesIn.listFiles().each { file ->
	   	  file.eachLine { line ->
	   	     //if(line.contains('=') && (result.length()==0 || !result.text.contains(line)) ) { 
	   	     if( (result.length()==0 || !result.text.contains(line)) ) {
	   	     	result << line + lineSeparator 
	   	     }
	   	  }
	   }
	}	   
}

task loadProps(dependsOn:[readBars, stripBars, combineBars]) {
	doLast {
		 java.util.LinkedHashMap  m1 = loadPropsToMap(new File("${brokerConfDir}${fileSeparator}flows.properties"))
		 java.util.LinkedHashMap  m2 = loadPropsToMap(new File("${brokerConfDir}${fileSeparator}flows.properties.ignore"))
		 java.util.LinkedHashMap  m3 = loadPropsToMap(new File("${barPropertiesIn.path}${fileSeparator}combined.bar.properties"))
		 java.util.LinkedHashMap  m4 = loadPropsToMap(new File("${barPropertiesOut}${fileSeparator}flows.properties"))
		 
		 project.ext.flowPropsMap = m1
		 project.ext.flowPropsIgnoredMap = m2
		 project.ext.combinedPropsMap = m3
		 project.ext.flowPropsOutMap = m4
	}
}

def	loadPropsToMap(propsFile) { 
		def propsMap = [:]
		propsFile.text.readLines().findAll { !it.startsWith ('#') && !it.isEmpty() && it.contains('#')}.each { line ->
			logger.debug "line: $line"
		
			def linearr = line.split('=')
			propsMap.put(linearr[0].trim(), linearr.length>1?linearr[1]?.trim():"DEFAULT_NULL_IGNORE")
	    }
		logger.debug "${propsFile.path}: ${propsMap}"
		return propsMap
}


/* detect delta */
task deltaBars(dependsOn:[loadProps]) {
	doLast {
	   description "detectDelta : check for not yet controlled properties"
	   new File("${barPropertiesOut}${fileSeparator}flows.properties.ignore").delete()
	   def delta = new File("${barPropertiesOut}${fileSeparator}flows.properties.ignore")
	   def deltaPropsMap = [:]
	   if(delta.exists()){
	   		deltaPropsMap = loadPropsToMap(delta)
	   }
	   	   
	   combinedPropsMap.each { entry  ->
		  if(entry.value!="DEFAULT_NULL_IGNORE"  && !flowPropsMap.containsKey(entry.key) && !flowPropsIgnoredMap.containsKey(entry.key) ) {
		   	     if( !delta.exists() || !deltaPropsMap.containsKey(entry.key) ){
		   	     	delta << entry.toString() + lineSeparator
		   	     } 
		   	     logger.error " delta detected: ${entry} "
		  }
		  
	   }
	   if(delta.exists()) {
	      throw new  TaskExecutionException(it, new Throwable("delta detected. please configure delta in ${configPath}${fileSeparator}flows.properties.ignore file.  "))
	   }
	   logger.info "no confguration deltas detected."
	}	   
}
